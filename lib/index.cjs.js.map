{"version":3,"file":"index.cjs.js","sources":["../src/index.ts"],"sourcesContent":["class SemaphoreItem {\n  private queue: Array<Function>;\n  private maxConcurrent: number;\n  /**\n   * The number of locks.\n   */\n  public count: number;\n\n  constructor(maxConcurrent: number) {\n    this.queue = [];\n    this.maxConcurrent = maxConcurrent;\n    this.count = 0;\n  }\n\n  get canAcquire(): boolean {\n    return this.count < this.maxConcurrent;\n  }\n\n  acquire(): Promise<void> {\n    if (this.canAcquire) {\n      this.count++;\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve) => this.queue.push(resolve));\n    }\n  }\n\n  release(): void {\n    const resolveFunc = this.queue.shift();\n\n    if (resolveFunc) {\n      // Give the micro task queue a small break instead of calling resolveFunc() directly\n      setTimeout(resolveFunc, 0);\n      // resolveFunc()\n    } else {\n      this.count--;\n    }\n  }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n  private semaphoreInstances: Record<string | number, SemaphoreItem>;\n  private maxConcurrent: number;\n\n  /**\n   *\n   * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n   */\n  constructor(maxConcurrent: number = 1) {\n    this.semaphoreInstances = {};\n    this.maxConcurrent = maxConcurrent;\n  }\n\n  private hasSemaphoreInstance(key: string | number = defaultKey) {\n    return Boolean(this.semaphoreInstances[key]);\n  }\n\n  private getSemaphoreInstance(key: string | number = defaultKey) {\n    if (!this.hasSemaphoreInstance(key)) {\n      this.semaphoreInstances[key] = new SemaphoreItem(this.maxConcurrent);\n    }\n    return this.semaphoreInstances[key];\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  private tidy(key: string | number = defaultKey): void {\n    if (\n      this.hasSemaphoreInstance(key) &&\n      this.getSemaphoreInstance(key).count == 0\n    ) {\n      delete this.semaphoreInstances[key];\n    }\n  }\n\n  /**\n   * A synchronous function to determine whether a lock can be acquired.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n   * otherwise.\n   */\n  canAcquire(key: string | number = defaultKey): boolean {\n    return this.getSemaphoreInstance(key).canAcquire;\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  acquire(key: string | number = defaultKey) {\n    return this.getSemaphoreInstance(key).acquire();\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  release(key: string | number = defaultKey): void {\n    this.getSemaphoreInstance(key).release();\n    this.tidy(key);\n  }\n\n  /**\n   * The number of active locks.  Will always be less or equal to `max`.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  count(key: string | number = defaultKey): number {\n    if (this.hasSemaphoreInstance(key)) {\n      return this.getSemaphoreInstance(key).count;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n   */\n  hasTasks(key: string | number = defaultKey): boolean {\n    return this.count(key) > 0;\n  }\n\n  /**\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async request<T>(\n    fn: Function,\n    key: string | number = defaultKey\n  ): Promise<T> {\n    try {\n      await this.acquire(key);\n      return await fn();\n    } finally {\n      this.release(key);\n    }\n  }\n\n  /**\n   * Asynchronously executes `fn` if a lock can be immediately acquired.\n   * Otherwise, returns null.\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async requestIfAvailable<T>(\n    fn: Function,\n    key: string | number = defaultKey\n  ): Promise<T | null> {\n    if (this.canAcquire(key)) {\n      return this.request(fn, key);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport default Semaphore;\n"],"names":[],"mappings":"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"}