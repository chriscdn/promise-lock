{"version":3,"file":"promise-semaphore.module.js","sources":["../src/index.ts"],"sourcesContent":["class SemaphoreItem {\n  private queue: Array<Function>;\n  private maxConcurrent: number;\n  /**\n   * The number of locks.\n   */\n  public count: number;\n\n  constructor(maxConcurrent: number) {\n    this.queue = [];\n    this.maxConcurrent = maxConcurrent;\n    this.count = 0;\n  }\n\n  get canAcquire(): boolean {\n    return this.count < this.maxConcurrent;\n  }\n\n  acquire(): Promise<void> {\n    if (this.canAcquire) {\n      this.count++;\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve) => this.queue.push(resolve));\n    }\n  }\n\n  release(): void {\n    const resolveFunc = this.queue.shift();\n\n    if (resolveFunc) {\n      // Give the micro task queue a small break instead of calling resolveFunc() directly\n      setTimeout(resolveFunc, 0);\n      // resolveFunc()\n    } else {\n      this.count--;\n    }\n  }\n}\n\nconst defaultKey = \"_default\";\n\nclass Semaphore {\n  private semaphoreInstances: Record<string | number, SemaphoreItem>;\n  private maxConcurrent: number;\n\n  /**\n   *\n   * @param {number} [maxConcurrent] The maximum number of concurrent locks.\n   */\n  constructor(maxConcurrent: number = 1) {\n    this.semaphoreInstances = {};\n    this.maxConcurrent = maxConcurrent;\n  }\n\n  private hasSemaphoreInstance(key: string | number = defaultKey) {\n    return Boolean(this.semaphoreInstances[key]);\n  }\n\n  private getSemaphoreInstance(key: string | number = defaultKey) {\n    if (!this.hasSemaphoreInstance(key)) {\n      this.semaphoreInstances[key] = new SemaphoreItem(this.maxConcurrent);\n    }\n    return this.semaphoreInstances[key];\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  private tidy(key: string | number = defaultKey): void {\n    if (\n      this.hasSemaphoreInstance(key) &&\n      this.getSemaphoreInstance(key).count === 0\n    ) {\n      delete this.semaphoreInstances[key];\n    }\n  }\n\n  /**\n   * A synchronous function to determine whether a lock can be acquired.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} Returns true if the lock on `key` can be acquired, false\n   * otherwise.\n   */\n  canAcquire(key: string | number = defaultKey): boolean {\n    return this.getSemaphoreInstance(key).canAcquire;\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  acquire(key: string | number = defaultKey) {\n    return this.getSemaphoreInstance(key).acquire();\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  release(key: string | number = defaultKey): void {\n    this.getSemaphoreInstance(key).release();\n    this.tidy(key);\n  }\n\n  /**\n   * The number of active locks.  Will always be less or equal to `max`.\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   */\n  count(key: string | number = defaultKey): number {\n    if (this.hasSemaphoreInstance(key)) {\n      return this.getSemaphoreInstance(key).count;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   *\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {boolean} True if the semaphore and key has locks, false otherwise.\n   */\n  hasTasks(key: string | number = defaultKey): boolean {\n    return this.count(key) > 0;\n  }\n\n  /**\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async request<T>(\n    fn: Function,\n    key: string | number = defaultKey\n  ): Promise<T> {\n    try {\n      await this.acquire(key);\n      return await fn();\n    } finally {\n      this.release(key);\n    }\n  }\n\n  /**\n   * Asynchronously executes `fn` if a lock can be immediately acquired.\n   * Otherwise, returns null.\n   *\n   * @param {Function<T>} fn The function to execute.\n   * @param {string | number} [key]- Optional, the semaphore key.\n   * @returns {Promise<T>}\n   */\n  async requestIfAvailable<T>(\n    fn: Function,\n    key: string | number = defaultKey\n  ): Promise<T | null> {\n    if (this.canAcquire(key)) {\n      return this.request(fn, key);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport default Semaphore;\n"],"names":["SemaphoreItem","maxConcurrent","this","queue","count","_proto","prototype","acquire","_this","canAcquire","Promise","resolve","push","release","resolveFunc","shift","setTimeout","key","get","defaultKey","Semaphore","semaphoreInstances","_proto2","hasSemaphoreInstance","Boolean","getSemaphoreInstance","tidy","hasTasks","request","fn","_this2","then","_finallyRethrows","_wasThrown","_result","e","reject","requestIfAvailable"],"mappings":"IAAMA,0BAQJ,SAAAA,EAAYC,GAAqBC,KAPzBC,WACAF,EAAAA,KAAAA,mBAIDG,EAAAA,KAAAA,aAGLF,KAAKC,MAAQ,GACbD,KAAKD,cAAgBA,EACrBC,KAAKE,MAAQ,CACf,CAAC,QAAAC,EAAAL,EAAAM,UAIAN,OAJAK,EAMDE,QAAA,eAAOC,EAAAN,KACL,OAAIA,KAAKO,YACPP,KAAKE,QACEM,QAAQC,eAEJD,QAAQ,SAACC,GAAY,OAAAH,EAAKL,MAAMS,KAAKD,EAAQ,EAE5D,EAACN,EAEDQ,QAAA,WACE,IAAMC,EAAcZ,KAAKC,MAAMY,QAE3BD,EAEFE,WAAWF,EAAa,GAGxBZ,KAAKE,OAET,IAACJ,OAAAiB,IAAA,aAAAC,IAvBD,WACE,OAAOhB,KAAKE,MAAQF,KAAKD,aAC3B,mgBAACD,CAAA,IAwBGmB,EAAa,WAEbC,eAAS,WAQb,SAAAA,EAAYnB,QAAAA,IAAAA,IAAAA,EAAwB,GAACC,KAP7BmB,wBAAkB,EAAAnB,KAClBD,mBAON,EAAAC,KAAKmB,mBAAqB,CAAE,EAC5BnB,KAAKD,cAAgBA,CACvB,CAAC,IAAAqB,EAAAF,EAAAd,UA+GA,OA/GAgB,EAEOC,qBAAA,SAAqBN,GAC3B,gBAD2BA,IAAAA,EAAuBE,GAC3CK,QAAQtB,KAAKmB,mBAAmBJ,GACzC,EAACK,EAEOG,qBAAA,SAAqBR,GAI3B,gBAJ2BA,IAAAA,EAAuBE,GAC7CjB,KAAKqB,qBAAqBN,KAC7Bf,KAAKmB,mBAAmBJ,GAAO,IAAIjB,EAAcE,KAAKD,gBAE7CC,KAACmB,mBAAmBJ,EACjC,EAACK,EAMOI,KAAA,SAAKT,QAAAA,IAAAA,IAAAA,EAAuBE,GAEhCjB,KAAKqB,qBAAqBN,IACe,IAAzCf,KAAKuB,qBAAqBR,GAAKb,cAExBF,KAAKmB,mBAAmBJ,EAEnC,EAACK,EASDb,WAAA,SAAWQ,GACT,gBADSA,IAAAA,EAAuBE,GACzBjB,KAAKuB,qBAAqBR,GAAKR,UACxC,EAACa,EAMDf,QAAA,SAAQU,GACN,gBADMA,IAAAA,EAAuBE,GAClBjB,KAACuB,qBAAqBR,GAAKV,SACxC,EAACe,EAMDT,QAAA,SAAQI,QAAAA,IAAAA,IAAAA,EAAuBE,GAC7BjB,KAAKuB,qBAAqBR,GAAKJ,UAC/BX,KAAKwB,KAAKT,EACZ,EAACK,EAODlB,MAAA,SAAMa,GACJ,gBADIA,IAAAA,EAAuBE,GACvBjB,KAAKqB,qBAAqBN,QAChBQ,qBAAqBR,GAAKb,MAGvC,CACH,EAACkB,EAODK,SAAA,SAASV,GACP,gBADOA,IAAAA,EAAuBE,GACvBjB,KAAKE,MAAMa,GAAO,CAC3B,EAACK,EAQKM,QAAOA,SACXC,EACAZ,YAAAA,IAAAA,EAAuBE,GAAU,IAAA,IAAAW,EAGzB5B,KAAIQ,OAAAA,QAAAC,gCADRD,QAAAC,QACImB,EAAKvB,QAAQU,IAAIc,KAAA,WAAA,OAAArB,QAAAC,QACVkB,IACd,4FAFWG,CADR,EAGHC,SAAAA,EAAAC,GACmB,GAAlBJ,EAAKjB,QAAQI,GAAKgB,EAAAC,MAAAA,SAAAA,CAAA,GAEtB,CAAC,MAAAC,GAAAzB,OAAAA,QAAA0B,OAAAD,EAAAb,CAAAA,EAAAA,EAUKe,mBAAkB,SACtBR,EACAZ,QAAAA,IAAAA,IAAAA,EAAuBE,GAAU,IAEjC,OAAIjB,KAAKO,WAAWQ,GAClBP,QAAAC,QADET,KACU0B,QAAQC,EAAIZ,IAExBP,QAAAC,QAAO,KAEX,CAAC,MAAAwB,GAAAzB,OAAAA,QAAA0B,OAAAD,EAAA,CAAA,EAAAf,CAAA,CA1HY"}